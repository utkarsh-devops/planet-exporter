programs:
  - name: tcp3
    metrics:
      counters:
        - name: ipv4_send_bytes
          help: tcp3
          table: ipv4_send_bytes
          labels:
            - name: saddr
              size: 4
              decoders:
                - name: inet_ip
            - name: daddr
              size: 4
              decoders:
                - name: inet_ip
        - name: ipv4_recv_bytes
          help: tcp3
          table: ipv4_recv_bytes
          labels:
            - name: saddr
              size: 4
              decoders:
                - name: inet_ip
            - name: daddr
              size: 4
              decoders:
                - name: inet_ip
        - name: ipv6_send_bytes
          help: tcp3
          table: ipv6_send_bytes
          labels:
            - name: saddr
              size: 16
              decoders:
                - name: inet_ip
            - name: daddr
              size: 16
              decoders:
                - name: inet_ip
        - name: ipv6_recv_bytes
          help: tcp3
          table: ipv6_recv_bytes
          labels:
            - name: saddr
              size: 16
              decoders:
                - name: inet_ip
            - name: daddr
              size: 16
              decoders:
                - name: inet_ip
    kprobes:
      tcp_sendmsg: tcp_sendmsg
      tcp_cleanup_rbuf: tcp_cleanup_rbuf
    code: |
      #include <linux/nsproxy.h>
      #include <linux/mount.h>
      #include <linux/ns_common.h>
      #include <uapi/linux/ptrace.h>
      #include <net/sock.h>
      #include <bcc/proto.h>
      struct ipv4_key_t {
          u32 saddr;
          u32 daddr;
      };
      BPF_HASH(ipv4_send_bytes, struct ipv4_key_t);
      BPF_HASH(ipv4_recv_bytes, struct ipv4_key_t);

      struct ipv6_key_t {
          unsigned __int128 saddr;
          unsigned __int128 daddr;
      };
      BPF_HASH(ipv6_send_bytes, struct ipv6_key_t);
      BPF_HASH(ipv6_recv_bytes, struct ipv6_key_t);

      int tcp_sendmsg(struct pt_regs *ctx, struct sock *sk,
          struct msghdr *msg, size_t size)
      {
          u32 pid = bpf_get_current_pid_tgid() >> 32;
          u16 dport = 0, family = sk->__sk_common.skc_family;

          if (family == AF_INET) {
              struct ipv4_key_t ipv4_key = {.daddr = sk->__sk_common.skc_daddr};
              ipv4_key.saddr = sk->__sk_common.skc_rcv_saddr;
              ipv4_key.daddr = sk->__sk_common.skc_daddr;
              // Uncomment following to aggregate the data.
              ipv4_send_bytes.increment(ipv4_key, size);
              // unsigned long long size_long_long = size;
              // ipv4_send_bytes.update(&ipv4_key, &size_long_long);
          } else {
              struct ipv6_key_t ipv6_key = {.daddr = sk->__sk_common.skc_daddr};
              //ipv6_key.saddr = sk->__sk_common.skc_rcv_saddr;
              //ipv6_key.daddr = sk->__sk_common.skc_daddr;
              bpf_probe_read_kernel(&ipv6_key.saddr, sizeof(ipv6_key.saddr),
                  &sk->__sk_common.skc_v6_rcv_saddr.in6_u.u6_addr32);
              bpf_probe_read_kernel(&ipv6_key.daddr, sizeof(ipv6_key.daddr),
                  &sk->__sk_common.skc_v6_daddr.in6_u.u6_addr32);
              // Uncomment following to aggregate the data.
              ipv6_send_bytes.increment(ipv6_key, size);
              // unsigned long long size_long_long = size;
              // ipv6_send_bytes.update(&ipv6_key, &size_long_long);
          }
          // else drop
          return 0;
        }
      /*
       * tcp_recvmsg() would be obvious to trace, but is less suitable because:
       * - we'd need to trace both entry and return, to have both sock and size
       * - misses tcp_read_sock() traffic
       * we'd much prefer tracepoints once they are available.
       */
      int tcp_cleanup_rbuf(struct pt_regs *ctx, struct sock *sk, int copied)
      {
          u16 dport = 0, family = sk->__sk_common.skc_family;
          u64 *val, zero = 0;
          if (copied <= 0)
              return 0;

          if (family == AF_INET) {
              struct ipv4_key_t ipv4_key = {.daddr = sk->__sk_common.skc_daddr};
              ipv4_key.saddr = sk->__sk_common.skc_rcv_saddr;
              ipv4_key.daddr = sk->__sk_common.skc_daddr;
              // Uncomment following to aggregate the data.
              ipv4_recv_bytes.increment(ipv4_key, copied);
              // unsigned long long copied_long_long = copied;
              // ipv4_recv_bytes.update(&ipv4_key, &copied_long_long);
          } else {
              struct ipv6_key_t ipv6_key = {.daddr = sk->__sk_common.skc_daddr};
              //ipv6_key.saddr = sk->__sk_common.skc_rcv_saddr;
              //ipv6_key.daddr = sk->__sk_common.skc_daddr;
              bpf_probe_read_kernel(&ipv6_key.saddr, sizeof(ipv6_key.saddr),
                  &sk->__sk_common.skc_v6_rcv_saddr.in6_u.u6_addr32);
              bpf_probe_read_kernel(&ipv6_key.daddr, sizeof(ipv6_key.daddr),
                  &sk->__sk_common.skc_v6_daddr.in6_u.u6_addr32);
              // Uncomment following to aggregate the data.
              ipv6_recv_bytes.increment(ipv6_key, copied);
              // unsigned long long size_long_long = size;
              // ipv6_send_bytes.update(&ipv6_key, &size_long_long);
          }
          // else drop
          return 0;
      }
